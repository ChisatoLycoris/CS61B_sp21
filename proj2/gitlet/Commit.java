package gitlet;

import java.io.File;
import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 *  Represents a gitlet commit object.
 *  Contains a log message, timestamp,
 *  a mapping of file names to blob references,
 *  a parent reference, and (for merge) a second parent reference.
 *
 *  @author Ming
 */
public class Commit implements Serializable {
    /**
     * List all instance variables of the Commit class here with a useful
     * comment above them describing what that variable represents and how that
     * variable is used. We've provided one example for `message`.
     */

    /** The message of this Commit. */
    private final String message;
    /** The timestamp of this Commit. */
    private final Date timestamp;
    /** The parent of this Commit in sha-1 string. */
    private final String parent;
    /** Another parent of this Commit in sha-1 string if this is a merge Commit. */
    private final String anotherParentIfMerge;
    /** The mapping of file names to blob in sha-1 string. */
    private Map<String, String> blobs;
    /** The hash String generated by sha-1 algorithm. */
    private String hash;

    /** Constructor for initialization. */
    public Commit() {
        message = "initial commit";
        parent = null;
        timestamp = new Date(0);
        anotherParentIfMerge = null;
        blobs = new HashMap<>();
    }

    /** Constructor for normal commit. */
    public Commit(String message, String parent,  String anotherParentIfMerge) {
        this.message = message;
        this.parent = parent;
        this.anotherParentIfMerge = anotherParentIfMerge;
        Commit parentCommit = Repository.findCommit(parent);
        blobs = new HashMap<>();
        for (String fileName : parentCommit.blobs.keySet()) {
            blobs.put(fileName, parentCommit.blobs.get(fileName));
        }
        timestamp = new Date();
        hash();
    }

    /** Constructor for merge commit.*/
//    public Commit(String message, String parent, String anotherParentIfMerge) {
//        this.message = message;
//        this.parent = parent;
//        this.anotherParentIfMerge = anotherParentIfMerge;
//        timestamp = new Date();
//    }

    void trackFile(String fileName, String fileHash) {
        blobs.put(fileName, fileHash);
    }

    void unTrackFile(String fileName, String fileHash) {
        blobs.remove(fileName, fileHash);
    }

    /** Save this Commit object in the COMMIT_DIR with hashString name. */
    public void persist() {
        File result = Utils.join(Repository.COMMIT_DIR, this.hash());
        Utils.writeObject(result, this);
    }

    /** Generate the hashString by sha-1 algorithm. */
    public String hash() {
        if (hash == null) {
            List<Object> metadata = new LinkedList<>();
            metadata.add(message);
            metadata.add(timestamp.toString());
            if (parent != null) {
                metadata.add(parent);
            }
            if (anotherParentIfMerge != null) {
                metadata.add(anotherParentIfMerge);
            }
            for (String key : blobs.keySet()) {
                metadata.add(key);
                metadata.add(blobs.get(key));
            }
            hash = Utils.sha1(metadata);
        }
        return hash;
    }

    public boolean isTracking(String fileName) {
        return blobs.containsKey(fileName);
    }

    public boolean isTracking(String fileName, String fileHash) {
        return fileHash.equals(blobs.get(fileName));
    }

    public String trackingFile(String fileName) {
        return blobs.get(fileName);
    }

    public Commit getParent() {
        if (parent != null) {
            return Repository.findCommit(parent);
        }
        return null;
    }

    public Commit getAnotherParent() {
        if (anotherParentIfMerge != null) {
            return Repository.findCommit(anotherParentIfMerge);
        }
        return null;
    }

    public boolean isMerged() {
        return anotherParentIfMerge != null;
    }

    public boolean isRoot() {
        return parent == null && anotherParentIfMerge == null;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("===");
        sb.append("\ncommit ");
        sb.append(this.hash());
        if (isMerged()) {
            sb.append("\nMerge: ").append(parent, 0, 7)
                    .append(" ").append(anotherParentIfMerge, 0, 7);
        }
        SimpleDateFormat dateFormat = new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy Z");
        sb.append("\nDate: ").append(dateFormat.format(timestamp)).append("\n");
        sb.append(message).append("\n");
        return sb.toString();
    }

    public String getMessage() {
        return message;
    }

    public Map<String, String> getBlobs() {
        Map<String, String> copy = new HashMap<>();
        blobs.keySet().forEach(fileName -> {
            copy.put(fileName, blobs.get(fileName));
        });
        return copy;
    }

    public Set<String> history() {
        Set<String> history = new HashSet<>();
        Commit temp = this;
        history.add(temp.hash());
        while (temp.parent != null) {
            if (temp.anotherParentIfMerge != null) {
                history.addAll(Repository.findCommit(temp.anotherParentIfMerge).history());
            }
            temp = Repository.findCommit(temp.parent);
            history.add(temp.hash());
        }
        return history;
    }
}
